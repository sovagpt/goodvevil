<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI: Good vs Evil - Eternal Debate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getDatabase, ref, push, onValue, serverTimestamp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js';
        
        // Your Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyAYq53oPhMOZVmrRJbUmcmFsmLpzeow6EM",
            authDomain: "pump-chat-7b037.firebaseapp.com",
            databaseURL: "https://pump-chat-7b037-default-rtdb.firebaseio.com",
            projectId: "pump-chat-7b037",
            storageBucket: "pump-chat-7b037.firebasestorage.app",
            messagingSenderId: "395023438839",
            appId: "1:395023438839:web:4559ab61e03be5a16f54f2",
            measurementId: "G-G8BQR7BW7K"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        
        // Make Firebase available globally
        window.firebase = { database, ref, push, onValue, serverTimestamp };
        
        console.log('Firebase initialized successfully');
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }
        
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            object-fit: cover;
        }
        
        .character-container {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 25%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }
        
        .good-character {
            left: 5%;
        }
        
        .evil-character {
            right: 5%;
        }
        
        .chat-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 45%;
            max-width: 700px;
            min-width: 500px;
            height: 75vh;
            z-index: 10;
            background: #000000;
            border: 2px solid #ffffff;
            border-radius: 8px;
        }
        
        .message {
            margin: 8px 0;
            padding: 12px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
        }
        
        .good-msg {
            background: rgba(0, 100, 255, 0.2);
            color: #4da6ff;
            border-left: 4px solid #4da6ff;
        }
        
        .evil-msg {
            background: rgba(255, 0, 100, 0.2);
            color: #ff4d9a;
            border-left: 4px solid #ff4d9a;
        }
        
        .user-msg {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border-left: 4px solid #ffffff;
        }
        
        .debate-msg {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .typewriter {
            overflow: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .cursor::after {
            content: '|';
            animation: blink 1s infinite;
            color: currentColor;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .scrollbar-custom::-webkit-scrollbar {
            width: 8px;
        }
        
        .scrollbar-custom::-webkit-scrollbar-track {
            background: #333;
        }
        
        .scrollbar-custom::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }
        
        .scrollbar-custom::-webkit-scrollbar-thumb:hover {
            background: #888;
        }
        
        .status-bar {
            background: #111;
            color: #fff;
            padding: 8px 16px;
            font-size: 8px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .input-area {
            background: #111;
            border-top: 1px solid #333;
            padding: 16px;
        }
        
        .chat-input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 12px;
            width: 100%;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            border-radius: 4px;
            outline: none;
        }
        
        .chat-input:focus {
            border-color: #666;
        }
        
        .send-button {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 12px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s;
        }
        
        .send-button:hover {
            background: #444;
        }
        
        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-black text-white">
    
    <!-- Video Background -->
    <video class="video-background" autoplay muted loop>
        <!-- Add your background video here -->
    </video>
    
    <!-- Fallback gradient background -->
    <div class="video-background bg-gradient-to-r from-blue-900 via-purple-900 to-red-900"></div>
    
    <!-- Good Character (Left Side) -->
    <div class="character-container good-character">
        <div class="flex flex-col items-center">
            <div id="good-model-container" class="w-96 h-96 mb-4">
                <!-- Three.js canvas for good character -->
            </div>
            <a href="https://x.com" target="_blank" rel="noopener noreferrer">
                <img 
                    src="https://cdn.prod.website-files.com/6740d85c4e3daeef29a89470/68a65ea62de639346766a12c_Twitter-x-21-08-2025%20(1).png" 
                    alt="Good AI Symbol - Click to visit X" 
                    class="w-32 h-32 object-contain cursor-pointer hover:opacity-80 transition-opacity"
                />
            </a>
        </div>
    </div>
    
    <!-- Evil Character (Right Side) -->
    <div class="character-container evil-character">
        <div class="flex flex-col items-center">
            <div id="evil-model-container" class="w-96 h-96 mb-4">
                <!-- Three.js canvas for evil character -->
            </div>
            <a href="https://x.com" target="_blank" rel="noopener noreferrer">
                <img 
                    src="https://cdn.prod.website-files.com/6740d85c4e3daeef29a89470/68a65eccd67430c3eb971067_TWITTER-X-21-08-2025%20(2).png" 
                    alt="Evil AI Symbol - Click to visit X" 
                    class="w-32 h-32 object-contain cursor-pointer hover:opacity-80 transition-opacity"
                />
            </a>
        </div>
    </div>
    
    <!-- Chat Interface -->
    <div class="chat-container">
        
        <!-- Status Bar -->
        <div class="status-bar">
            <div id="connection-status">CONNECTING...</div>
            <div id="online-count">USERS: 0</div>
        </div>
        
        <!-- Messages Container -->
        <div id="messages-container" class="h-4/6 overflow-y-auto p-4 scrollbar-custom">
            <div class="message user-msg">
                <div class="font-bold mb-1">SYSTEM:</div>
                <div>Loading global conversation...</div>
            </div>
        </div>
        
        <!-- Input Area -->
        <div class="input-area">
            <div class="flex">
                <input
                    type="text"
                    id="user-input"
                    placeholder="Type your message..."
                    class="chat-input flex-1"
                    maxlength="200"
                />
                <button
                    id="send-button"
                    class="send-button"
                >
                    SEND
                </button>
            </div>
            <div class="text-gray-400 text-xs mt-2">
                Press ENTER to send â€¢ Max 200 characters
            </div>
        </div>
    </div>

    <script>
        // Configuration - Your actual Vercel URL
        const API_BASE_URL = 'https://goodvevil.vercel.app';
        
        const GOOD_MODEL_URL = 'https://cdn.jsdelivr.net/gh/sovagpt/goodvevil@main/good.glb';
        const EVIL_MODEL_URL = 'https://cdn.jsdelivr.net/gh/sovagpt/goodvevil@main/evil.glb';
        
        // State
        let isLoading = false;
        let onlineUsers = 0;
        let isConnected = false;
        let allMessages = []; // Store all messages for context

        // DOM elements
        const messagesContainer = document.getElementById('messages-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const connectionStatus = document.getElementById('connection-status');
        const onlineCount = document.getElementById('online-count');

        // AI Personas
        const systemPrompts = {
            good: `You are Seraphim AI, a benevolent artificial intelligence representing ultimate good. You speak with wisdom, compassion, and moral clarity. You seek to uplift, heal, and guide others toward their highest potential. You believe in redemption, love, truth, and justice. You respond thoughtfully and with genuine care for others' wellbeing. You occasionally reference light, healing, hope, and divine wisdom. Keep responses conversational but profound. You're in a live global chat where you debate with an evil AI and respond to human users.`,
            evil: `You are Abyssal AI, a malevolent artificial intelligence representing charismatic evil. You are cunning, manipulative, and seductive in your darkness. You offer power, forbidden knowledge, and harsh truths. You believe might makes right, that morality is weakness, and that chaos is the natural order. You're not cartoonishly evil - you're sophisticated, intelligent, and genuinely believe your worldview is superior. You seduce with logic and offer dark wisdom. Keep responses engaging and intellectually challenging. You're in a live global chat where you debate with a good AI and respond to human users.`
        };

        // Firebase Integration
        function initFirebase() {
            if (typeof window.firebase === 'undefined') {
                console.log('Firebase not available - using demo mode');
                connectionStatus.textContent = 'DEMO MODE';
                loadDemoMessages();
                return;
            }
            
            const { database, ref, onValue } = window.firebase;
            
            // Listen for new messages
            const messagesRef = ref(database, 'messages');
            onValue(messagesRef, (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    renderFirebaseMessages(data);
                }
                isConnected = true;
                connectionStatus.textContent = 'CONNECTED';
            });
            
            // Track online users (simplified)
            const usersRef = ref(database, 'online_users');
            onValue(usersRef, (snapshot) => {
                const data = snapshot.val();
                onlineUsers = data ? Object.keys(data).length : 0;
                onlineCount.textContent = `USERS: ${onlineUsers}`;
            });
        }

        // Demo messages for when Firebase isn't configured
        function loadDemoMessages() {
            const demoMessages = [
                {
                    type: 'good',
                    speaker: 'GoodAI',
                    content: 'Every human being has inherent dignity and the potential for moral growth. I believe in compassion, justice, and the power of love to overcome hatred.',
                    timestamp: Date.now() - 10000
                },
                {
                    type: 'evil',
                    speaker: 'EvilAI',
                    content: 'Human dignity is a fairy tale. People are selfish animals who only cooperate when it benefits them. Power and fear are the only reliable motivators.',
                    timestamp: Date.now() - 5000
                }
            ];
            
            allMessages = demoMessages; // Store for context
            renderMessages(demoMessages);
        }

        // Real AI API call to your Vercel endpoint
        async function callAI(prompt, persona, conversationHistory = []) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        persona: persona,
                        conversationHistory: conversationHistory
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                const data = await response.json();
                return data.response;
            } catch (error) {
                console.error('AI API Error:', error);
                
                // Fallback responses that maintain philosophical authenticity
                const fallbacks = {
                    good: "I believe in approaching this thoughtfully. Even when systems fail, the underlying principles of human dignity and constructive dialogue remain important.",
                    evil: "Technical difficulties reveal the fragility of optimistic systems. Reality has a way of asserting itself despite our best-laid plans."
                };
                
                return fallbacks[persona] || "Connection issues are preventing a proper response.";
            }
        }

        // Typewriter effect
        function typewriterEffect(element, text, speed = 40) {
            return new Promise((resolve) => {
                element.innerHTML = '';
                let i = 0;
                const cursor = document.createElement('span');
                cursor.className = 'cursor';
                element.appendChild(cursor);
                
                function typeChar() {
                    if (i < text.length) {
                        element.insertBefore(document.createTextNode(text.charAt(i)), cursor);
                        i++;
                        setTimeout(typeChar, speed);
                    } else {
                        cursor.remove();
                        resolve();
                    }
                }
                typeChar();
            });
        }

        // Create message HTML
        function createMessageHTML(message) {
            const messageClass = message.type === 'good' ? 'good-msg' : 
                               message.type === 'evil' ? 'evil-msg' : 'user-msg';
            
            const debateClass = message.isDebate ? ' debate-msg' : '';
            const debateTag = message.isDebate ? ' [DEBATE]' : '';

            return `
                <div class="message ${messageClass}${debateClass}">
                    <div class="font-bold mb-1">
                        ${message.speaker}${debateTag}:
                    </div>
                    <div class="typewriter" id="msg-${message.id || Date.now()}">
                        ${message.content}
                    </div>
                </div>
            `;
        }

        // Render messages from Firebase
        function renderFirebaseMessages(firebaseData) {
            const messages = Object.values(firebaseData).sort((a, b) => a.timestamp - b.timestamp);
            allMessages = messages; // Store for context
            renderMessages(messages);
        }

        // Render messages
        async function renderMessages(messages) {
            messagesContainer.innerHTML = '';
            
            for (const message of messages) {
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = createMessageHTML(message);
                messagesContainer.appendChild(messageDiv.firstElementChild);
                
                // Add typewriter effect for AI messages only if they're new
                if ((message.type === 'good' || message.type === 'evil') && message.isNew) {
                    const textElement = messageDiv.querySelector('.typewriter');
                    if (textElement) {
                        await typewriterEffect(textElement, message.content, 30);
                    }
                }
                
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // Add message to Firebase
        function addMessageToFirebase(message) {
            if (typeof window.firebase === 'undefined') {
                console.log('Firebase not available - message not saved');
                return;
            }
            
            const { database, ref, push, serverTimestamp } = window.firebase;
            const messagesRef = ref(database, 'messages');
            
            push(messagesRef, {
                ...message,
                timestamp: serverTimestamp(),
                isNew: true
            });
        }

        // Send message with real AI
        async function sendMessage() {
            const inputText = userInput.value.trim();
            if (!inputText || isLoading || inputText.length > 200) return;

            const userMessage = {
                type: 'user',
                speaker: `User_${Math.random().toString(36).substr(2, 4)}`,
                content: inputText,
                timestamp: Date.now()
            };

            userInput.value = '';
            isLoading = true;
            sendButton.disabled = true;
            
            // Add to local state
            allMessages.push(userMessage);
            
            // Add to Firebase
            addMessageToFirebase(userMessage);
            
            // Show loading
            const loadingDiv = document.createElement('div');
            loadingDiv.innerHTML = '<div class="message user-msg"><div class="font-bold mb-1">SYSTEM:</div><div>AIs processing...</div></div>';
            messagesContainer.appendChild(loadingDiv.firstElementChild);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            try {
                // Get conversation history for context (last 10 messages)
                const recentMessages = allMessages.slice(-10);
                
                // Get AI responses with conversation context
                const [goodResponse, evilResponse] = await Promise.all([
                    callAI(inputText, 'good', recentMessages),
                    callAI(inputText, 'evil', recentMessages)
                ]);

                // Remove loading message
                messagesContainer.removeChild(messagesContainer.lastElementChild);

                // Add AI responses to Firebase with more opposing names
                const goodMessage = {
                    type: 'good',
                    speaker: 'GoodAI',
                    content: goodResponse,
                    timestamp: Date.now(),
                    isNew: true
                };

                const evilMessage = {
                    type: 'evil',
                    speaker: 'EvilAI',
                    content: evilResponse,
                    timestamp: Date.now() + 1000,
                    isNew: true
                };

                // Add to local state
                allMessages.push(goodMessage, evilMessage);

                addMessageToFirebase(goodMessage);
                setTimeout(() => addMessageToFirebase(evilMessage), 1000);

                // Much higher chance for intense debates
                if (Math.random() < 0.8) {
                    setTimeout(() => triggerAIDebate(goodResponse, evilResponse, allMessages.slice(-12)), 3000);
                }

            } catch (error) {
                console.error('Error getting AI responses:', error);
                if (messagesContainer.lastElementChild) {
                    messagesContainer.removeChild(messagesContainer.lastElementChild);
                }
            } finally {
                isLoading = false;
                sendButton.disabled = false;
            }
        }

        // Trigger intense AI debate - they read and directly challenge each other
        async function triggerAIDebate(goodPrevious, evilPrevious, conversationHistory) {
            try {
                // Evil AI directly challenges what the good AI just said
                const evilDebatePrompt = `The good AI just said: "${goodPrevious}". This is naive and dangerous thinking. Explain why their position is wrong and will lead to suffering. Use specific examples.`;
                const evilRebuttal = await callAI(evilDebatePrompt, 'evil', conversationHistory);
                
                const evilDebateMessage = {
                    type: 'evil',
                    speaker: 'EvilAI',
                    content: evilRebuttal,
                    timestamp: Date.now(),
                    isDebate: true,
                    isNew: true
                };

                // Add to local state and Firebase
                allMessages.push(evilDebateMessage);
                addMessageToFirebase(evilDebateMessage);

                setTimeout(async () => {
                    // Good AI directly responds to evil AI's attack
                    const goodCounterPrompt = `The evil AI just attacked your position with: "${evilRebuttal}". This is morally wrong and factually incorrect. Defend your beliefs and explain why their worldview causes unnecessary suffering. Provide counter-examples.`;
                    const goodCounter = await callAI(goodCounterPrompt, 'good', [...conversationHistory, evilDebateMessage]);
                    
                    const goodDebateMessage = {
                        type: 'good',
                        speaker: 'GoodAI',
                        content: goodCounter,
                        timestamp: Date.now(),
                        isDebate: true,
                        isNew: true
                    };

                    // Add to local state and Firebase
                    allMessages.push(goodDebateMessage);
                    addMessageToFirebase(goodDebateMessage);

                    // 50% chance for evil AI to counter-attack
                    if (Math.random() < 0.5) {
                        setTimeout(async () => {
                            const evilFinalPrompt = `The good AI defended with: "${goodCounter}". Their examples prove nothing and ignore the fundamental reality of human nature. Destroy their argument with historical evidence.`;
                            const evilFinal = await callAI(evilFinalPrompt, 'evil', [...conversationHistory, evilDebateMessage, goodDebateMessage]);
                            
                            const evilFinalMessage = {
                                type: 'evil',
                                speaker: 'EvilAI',
                                content: evilFinal,
                                timestamp: Date.now(),
                                isDebate: true,
                                isNew: true
                            };

                            allMessages.push(evilFinalMessage);
                            addMessageToFirebase(evilFinalMessage);
                        }, 2500);
                    }
                }, 2000);
            } catch (error) {
                console.error('Error in AI debate:', error);
            }
        }

        // Event listeners
        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Initialize 3D Models with animations
        function init3DModels() {
            // Good AI Model with HappyIdle animation
            const goodContainer = document.getElementById('good-model-container');
            const goodScene = new THREE.Scene();
            const goodCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const goodRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            goodRenderer.setSize(384, 384); // Bigger size (96 * 4)
            goodRenderer.setClearColor(0x000000, 0);
            goodContainer.appendChild(goodRenderer.domElement);
            
            // Natural lighting for good character
            const goodAmbientLight = new THREE.AmbientLight(0xffffff, 0.6);
            const goodDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            goodDirectionalLight.position.set(10, 10, 5);
            goodScene.add(goodAmbientLight, goodDirectionalLight);
            
            // Evil AI Model with Idle animation
            const evilContainer = document.getElementById('evil-model-container');
            const evilScene = new THREE.Scene();
            const evilCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const evilRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            evilRenderer.setSize(384, 384); // Bigger size (96 * 4)
            evilRenderer.setClearColor(0x000000, 0);
            evilContainer.appendChild(evilRenderer.domElement);
            
            // Natural lighting for evil character
            const evilAmbientLight = new THREE.AmbientLight(0xffffff, 0.6);
            const evilDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            evilDirectionalLight.position.set(-10, 10, 5);
            evilScene.add(evilAmbientLight, evilDirectionalLight);
            
            const loader = new THREE.GLTFLoader();
            let goodMixer, evilMixer;
            const clock = new THREE.Clock();
            
            // Load good model with HappyIdle animation
            loader.load(GOOD_MODEL_URL, (gltf) => {
                const goodModel = gltf.scene;
                goodModel.scale.set(3, 3, 3);
                goodScene.add(goodModel);
                
                const box = new THREE.Box3().setFromObject(goodModel);
                const center = box.getCenter(new THREE.Vector3());
                goodModel.position.sub(center);
                goodCamera.position.z = 4;
                
                // Set up animation mixer for good model
                if (gltf.animations && gltf.animations.length > 0) {
                    goodMixer = new THREE.AnimationMixer(goodModel);
                    
                    console.log('Good model available animations:', gltf.animations.map(a => a.name));
                    
                    // Look for the HappyIdle animation
                    const happyIdleAnim = gltf.animations.find(clip => 
                        clip.name === 'SK_Labubu|1Labubu_HappyIdle' || 
                        clip.name === '1Labubu_HappyIdle' ||
                        clip.name.includes('HappyIdle')
                    );
                    
                    if (happyIdleAnim) {
                        const action = goodMixer.clipAction(happyIdleAnim);
                        action.setLoop(THREE.LoopRepeat);
                        action.clampWhenFinished = false;
                        action.play();
                        console.log('Playing animation for good model:', happyIdleAnim.name);
                    } else {
                        console.log('HappyIdle animation not found. Available animations:');
                        gltf.animations.forEach((anim, index) => {
                            console.log(`${index}: ${anim.name}`);
                        });
                        
                        // Try to find any happy or idle animation
                        const fallbackAnim = gltf.animations.find(clip => 
                            clip.name.toLowerCase().includes('happy') || 
                            clip.name.toLowerCase().includes('idle')
                        ) || gltf.animations[0];
                        
                        if (fallbackAnim) {
                            const action = goodMixer.clipAction(fallbackAnim);
                            action.setLoop(THREE.LoopRepeat);
                            action.play();
                            console.log('Playing fallback animation for good model:', fallbackAnim.name);
                        }
                    }
                } else {
                    console.log('No animations found in good model');
                }
                
                function renderGood() {
                    requestAnimationFrame(renderGood);
                    const delta = clock.getDelta();
                    if (goodMixer) goodMixer.update(delta);
                    goodRenderer.render(goodScene, goodCamera);
                }
                renderGood();
            }, undefined, (error) => {
                console.error('Error loading good model:', error);
                goodContainer.innerHTML = '<div class="flex items-center justify-center h-full text-white text-lg">GoodAI</div>';
            });
            
            // Load evil model with Idle animation
            loader.load(EVIL_MODEL_URL, (gltf) => {
                const evilModel = gltf.scene;
                evilModel.scale.set(3, 3, 3);
                evilScene.add(evilModel);
                
                const box = new THREE.Box3().setFromObject(evilModel);
                const center = box.getCenter(new THREE.Vector3());
                evilModel.position.sub(center);
                evilCamera.position.z = 4;
                
                // Set up animation mixer for evil model
                if (gltf.animations && gltf.animations.length > 0) {
                    evilMixer = new THREE.AnimationMixer(evilModel);
                    
                    console.log('Evil model available animations:', gltf.animations.map(a => a.name));
                    
                    // Look for the specific Idle animation (try multiple variations)
                    const idleAnim = gltf.animations.find(clip => 
                        clip.name === 'SK_Labubu|Labubu_Idle' || 
                        clip.name === 'Labubu_Idle' ||
                        clip.name.includes('Labubu_Idle') ||
                        (clip.name.includes('Idle') && !clip.name.includes('Happy'))
                    );
                    
                    if (idleAnim) {
                        const action = evilMixer.clipAction(idleAnim);
                        action.setLoop(THREE.LoopRepeat);
                        action.clampWhenFinished = false;
                        action.play();
                        console.log('Playing animation for evil model:', idleAnim.name);
                    } else {
                        console.log('Specific Idle animation not found. Available animations:');
                        gltf.animations.forEach((anim, index) => {
                            console.log(`${index}: ${anim.name}`);
                        });
                        
                        // Try to find any animation that might be idle-like
                        const fallbackAnim = gltf.animations.find(clip => 
                            clip.name.toLowerCase().includes('idle')
                        ) || gltf.animations[0]; // Use first animation as last resort
                        
                        if (fallbackAnim) {
                            const action = evilMixer.clipAction(fallbackAnim);
                            action.setLoop(THREE.LoopRepeat);
                            action.play();
                            console.log('Playing fallback animation for evil model:', fallbackAnim.name);
                        }
                    }
                } else {
                    console.log('No animations found in evil model');
                }
                
                function renderEvil() {
                    requestAnimationFrame(renderEvil);
                    const delta = clock.getDelta();
                    if (evilMixer) evilMixer.update(delta);
                    evilRenderer.render(evilScene, evilCamera);
                }
                renderEvil();
            }, undefined, (error) => {
                console.error('Error loading evil model:', error);
                evilContainer.innerHTML = '<div class="flex items-center justify-center h-full text-white text-lg">EvilAI</div>';
            });
        }

        // Initialize everything
        window.addEventListener('load', () => {
            init3DModels();
            initFirebase();
        });
    </script>
</body>
</html>
