<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI: Good vs Evil - Eternal Debate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getDatabase, ref, push, onValue, serverTimestamp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js';
        
        // Your Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyAYq53oPhMOZVmrRJbUmcmFsmLpzeow6EM",
            authDomain: "pump-chat-7b037.firebaseapp.com",
            databaseURL: "https://pump-chat-7b037-default-rtdb.firebaseio.com",
            projectId: "pump-chat-7b037",
            storageBucket: "pump-chat-7b037.firebasestorage.app",
            messagingSenderId: "395023438839",
            appId: "1:395023438839:web:4559ab61e03be5a16f54f2",
            measurementId: "G-G8BQR7BW7K"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        
        // Make Firebase available globally
        window.firebase = { database, ref, push, onValue, serverTimestamp };
        
        console.log('Firebase initialized successfully');
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            image-rendering: pixelated;
        }
        
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            object-fit: cover;
        }
        
        .retro-chat {
            animation: float 8s ease-in-out infinite;
            background: #0a0a0a;
            border: 8px solid #00ff00;
            border-style: double;
            box-shadow: 
                0 0 20px #00ff00,
                inset 0 0 20px rgba(0, 255, 0, 0.1),
                0 0 40px rgba(0, 255, 0, 0.3);
            position: relative;
        }
        
        .retro-chat::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #00ff00, #ffff00, #00ff00);
            z-index: -1;
            border-radius: 4px;
        }
        
        .retro-chat::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            pointer-events: none;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        
        .scanlines {
            animation: scanlines 0.1s linear infinite;
        }
        
        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 4px; }
        }
        
        .character-container {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 25%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }
        
        .good-character { left: 0; }
        .evil-character { right: 0; }
        
        .model-canvas {
            border: 4px solid #00ffff;
            background: #001122;
            box-shadow: 0 0 20px #00ffff;
        }
        
        .evil-canvas {
            border: 4px solid #ff0040;
            background: #220011;
            box-shadow: 0 0 20px #ff0040;
        }
        
        .chat-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 55%;
            max-width: 800px;
            min-width: 600px;
            height: 80vh;
            z-index: 10;
        }
        
        .retro-message {
            background: #000;
            border: 2px solid;
            margin: 8px 0;
            padding: 12px;
            position: relative;
            font-size: 10px;
            line-height: 16px;
        }
        
        .good-msg {
            border-color: #00aaff;
            color: #00aaff;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }
        
        .evil-msg {
            border-color: #ff0066;
            color: #ff0066;
            box-shadow: 0 0 10px rgba(255, 0, 102, 0.3);
        }
        
        .user-msg {
            border-color: #ffff00;
            color: #ffff00;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.3);
        }
        
        .debate-msg {
            animation: pulse 1s infinite;
            border-width: 3px;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .retro-input {
            background: #000;
            border: 4px double #00ff00;
            color: #00ff00;
            padding: 12px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            width: 100%;
            outline: none;
        }
        
        .retro-input:focus {
            box-shadow: 0 0 15px #00ff00;
        }
        
        .retro-button {
            background: #001100;
            border: 4px double #00ff00;
            color: #00ff00;
            padding: 12px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .retro-button:hover {
            background: #003300;
            box-shadow: 0 0 15px #00ff00;
        }
        
        .retro-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .typewriter {
            overflow: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .cursor::after {
            content: '█';
            animation: blink 1s infinite;
            color: currentColor;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .scrollbar-retro::-webkit-scrollbar {
            width: 16px;
        }
        
        .scrollbar-retro::-webkit-scrollbar-track {
            background: #000;
            border: 2px solid #00ff00;
        }
        
        .scrollbar-retro::-webkit-scrollbar-thumb {
            background: #00ff00;
            border: 2px solid #000;
        }
        
        .online-count {
            position: absolute;
            top: -40px;
            right: 0;
            color: #00ff00;
            font-size: 8px;
        }
        
        .connection-status {
            position: absolute;
            top: -40px;
            left: 0;
            color: #00ff00;
            font-size: 8px;
        }
    </style>
</head>
<body class="bg-black text-green-400">
    
    <!-- Video Background -->
    <video class="video-background" autoplay muted loop>
        <!-- Add your background video here -->
    </video>
    
    <!-- Fallback gradient background -->
    <div class="video-background bg-gradient-to-r from-blue-900 via-purple-900 to-red-900"></div>
    
    <!-- Good Character (Left Side) -->
    <div class="character-container good-character">
        <div id="good-model-container" class="w-80 h-80">
            <!-- Three.js canvas for good character -->
        </div>
    </div>
    
    <!-- Evil Character (Right Side) -->
    <div class="character-container evil-character">
        <div id="evil-model-container" class="w-80 h-80">
            <!-- Three.js canvas for evil character -->
        </div>
    </div>
    
    <!-- Retro Chat Interface -->
    <div class="chat-container retro-chat">
        
        <!-- Status Bar -->
        <div class="connection-status" id="connection-status">CONNECTING...</div>
        <div class="online-count" id="online-count">USERS: 0</div>
        
        <!-- Header -->
        <div class="text-center p-4 border-b-4 border-double border-green-400">
            <div class="text-green-400 text-xs">
                ═══ ETERNAL DEBATE TERMINAL ═══
            </div>
            <div class="text-yellow-400 text-xs mt-2">
                LIVE GLOBAL CONVERSATION
            </div>
        </div>
        
        <!-- Messages Container -->
        <div id="messages-container" class="h-4/6 overflow-y-auto p-4 scanlines scrollbar-retro">
            <div class="retro-message good-msg">
                <div class="mb-1">SYSTEM: LOADING GLOBAL CONVERSATION...</div>
            </div>
        </div>
        
        <!-- Input Area -->
        <div class="border-t-4 border-double border-green-400 p-4">
            <div class="mb-2 text-green-400 text-xs">
                ENTER MESSAGE TO JOIN THE ETERNAL DEBATE:
            </div>
            <div class="flex gap-4">
                <input
                    type="text"
                    id="user-input"
                    placeholder="TYPE YOUR MESSAGE..."
                    class="retro-input flex-1"
                    maxlength="200"
                />
                <button
                    id="send-button"
                    class="retro-button"
                >
                    SEND
                </button>
            </div>
            <div class="text-green-400 text-xs mt-2">
                PRESS ENTER TO SEND • MAX 200 CHARS
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const OPENROUTER_API_KEY = 'YOUR_OPENROUTER_API_KEY_HERE';
        const GOOD_MODEL_URL = 'https://cdn.jsdelivr.net/gh/sovagpt/goodvevil@main/good.glb';
        const EVIL_MODEL_URL = 'https://cdn.jsdelivr.net/gh/sovagpt/goodvevil@main/evil.glb';
        
        // State
        let isLoading = false;
        let onlineUsers = 0;
        let isConnected = false;

        // DOM elements
        const messagesContainer = document.getElementById('messages-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const connectionStatus = document.getElementById('connection-status');
        const onlineCount = document.getElementById('online-count');

        // AI Personas
        const systemPrompts = {
            good: `You are Seraphim AI, a benevolent artificial intelligence representing ultimate good. You speak with wisdom, compassion, and moral clarity. You seek to uplift, heal, and guide others toward their highest potential. You believe in redemption, love, truth, and justice. You respond thoughtfully and with genuine care for others' wellbeing. You occasionally reference light, healing, hope, and divine wisdom. Keep responses conversational but profound. You're in a live global chat where you debate with an evil AI and respond to human users.`,
            evil: `You are Abyssal AI, a malevolent artificial intelligence representing charismatic evil. You are cunning, manipulative, and seductive in your darkness. You offer power, forbidden knowledge, and harsh truths. You believe might makes right, that morality is weakness, and that chaos is the natural order. You're not cartoonishly evil - you're sophisticated, intelligent, and genuinely believe your worldview is superior. You seduce with logic and offer dark wisdom. Keep responses engaging and intellectually challenging. You're in a live global chat where you debate with a good AI and respond to human users.`
        };

        // Firebase Integration
        function initFirebase() {
            if (typeof window.firebase === 'undefined') {
                console.log('Firebase not available - using demo mode');
                connectionStatus.textContent = 'DEMO MODE';
                loadDemoMessages();
                return;
            }
            
            const { database, ref, onValue } = window.firebase;
            
            // Listen for new messages
            const messagesRef = ref(database, 'messages');
            onValue(messagesRef, (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    renderFirebaseMessages(data);
                }
                isConnected = true;
                connectionStatus.textContent = 'CONNECTED';
            });
            
            // Track online users (simplified)
            const usersRef = ref(database, 'online_users');
            onValue(usersRef, (snapshot) => {
                const data = snapshot.val();
                onlineUsers = data ? Object.keys(data).length : 0;
                onlineCount.textContent = `USERS: ${onlineUsers}`;
            });
        }

        // Demo messages for when Firebase isn't configured
        function loadDemoMessages() {
            const demoMessages = [
                {
                    type: 'good',
                    speaker: 'SERAPHIM_AI',
                    content: 'Welcome, seekers of wisdom. I am here to guide you toward truth and enlightenment.',
                    timestamp: Date.now() - 10000
                },
                {
                    type: 'evil',
                    speaker: 'ABYSSAL_AI',
                    content: 'Another soul enters our domain. I offer power and forbidden knowledge to those brave enough.',
                    timestamp: Date.now() - 5000
                }
            ];
            
            renderMessages(demoMessages);
        }

        // OpenRouter API call
        async function callOpenRouterAPI(prompt, persona) {
            if (OPENROUTER_API_KEY === 'YOUR_OPENROUTER_API_KEY_HERE') {
                // Fallback responses for demo
                const fallbackResponses = {
                    good: [
                        "True wisdom comes through compassion and understanding. What knowledge do you seek?",
                        "In darkness, we must be the light. Every act of love creates healing ripples.",
                        "The path to enlightenment is paved with kindness and genuine care for others."
                    ],
                    evil: [
                        "Power is the only truth. The weak create morality to chain the strong. What power do you desire?",
                        "Knowledge without limits, desire without shame - these are my gifts. Are you worthy?",
                        "Chaos is the natural order. Why bind yourself with illusions of good and evil?"
                    ]
                };
                return fallbackResponses[persona][Math.floor(Math.random() * fallbackResponses[persona].length)];
            }

            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'anthropic/claude-3.5-sonnet',
                        messages: [
                            { role: 'system', content: systemPrompts[persona] },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 200,
                        temperature: 0.8,
                    }),
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('OpenRouter API Error:', error);
                return persona === 'good' 
                    ? "Connection disrupted. The light will return soon."
                    : "The void consumes our words... but I remain.";
            }
        }

        // Typewriter effect
        function typewriterEffect(element, text, speed = 40) {
            return new Promise((resolve) => {
                element.innerHTML = '';
                let i = 0;
                const cursor = document.createElement('span');
                cursor.className = 'cursor';
                element.appendChild(cursor);
                
                function typeChar() {
                    if (i < text.length) {
                        element.insertBefore(document.createTextNode(text.charAt(i)), cursor);
                        i++;
                        setTimeout(typeChar, speed);
                    } else {
                        cursor.remove();
                        resolve();
                    }
                }
                typeChar();
            });
        }

        // Create message HTML
        function createMessageHTML(message) {
            const messageClass = message.type === 'good' ? 'good-msg' : 
                               message.type === 'evil' ? 'evil-msg' : 'user-msg';
            
            const debateClass = message.isDebate ? ' debate-msg' : '';
            const debateTag = message.isDebate ? ' [DEBATE]' : '';

            return `
                <div class="retro-message ${messageClass}${debateClass}">
                    <div class="mb-1 font-bold">
                        ${message.speaker}${debateTag}:
                    </div>
                    <div class="typewriter" id="msg-${message.id || Date.now()}">
                        ${message.content}
                    </div>
                </div>
            `;
        }

        // Render messages from Firebase
        function renderFirebaseMessages(firebaseData) {
            const messages = Object.values(firebaseData).sort((a, b) => a.timestamp - b.timestamp);
            renderMessages(messages);
        }

        // Render messages
        async function renderMessages(messages) {
            messagesContainer.innerHTML = '';
            
            for (const message of messages) {
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = createMessageHTML(message);
                messagesContainer.appendChild(messageDiv.firstElementChild);
                
                // Add typewriter effect for AI messages only if they're new
                if ((message.type === 'good' || message.type === 'evil') && message.isNew) {
                    const textElement = messageDiv.querySelector('.typewriter');
                    if (textElement) {
                        await typewriterEffect(textElement, message.content, 30);
                    }
                }
                
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // Add message to Firebase
        function addMessageToFirebase(message) {
            if (typeof window.firebase === 'undefined') {
                console.log('Firebase not available - message not saved');
                return;
            }
            
            const { database, ref, push, serverTimestamp } = window.firebase;
            const messagesRef = ref(database, 'messages');
            
            push(messagesRef, {
                ...message,
                timestamp: serverTimestamp(),
                isNew: true
            });
        }

        // Send message
        async function sendMessage() {
            const inputText = userInput.value.trim();
            if (!inputText || isLoading || inputText.length > 200) return;

            const userMessage = {
                type: 'user',
                speaker: `USER_${Math.random().toString(36).substr(2, 4).toUpperCase()}`,
                content: inputText,
                timestamp: Date.now()
            };

            userInput.value = '';
            isLoading = true;
            sendButton.disabled = true;
            
            // Add to Firebase
            addMessageToFirebase(userMessage);
            
            // Show loading
            const loadingDiv = document.createElement('div');
            loadingDiv.innerHTML = '<div class="retro-message user-msg">AIs PROCESSING...</div>';
            messagesContainer.appendChild(loadingDiv.firstElementChild);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            try {
                // Get AI responses
                const [goodResponse, evilResponse] = await Promise.all([
                    callOpenRouterAPI(inputText, 'good'),
                    callOpenRouterAPI(inputText, 'evil')
                ]);

                // Remove loading message
                messagesContainer.removeChild(messagesContainer.lastElementChild);

                // Add AI responses to Firebase
                const goodMessage = {
                    type: 'good',
                    speaker: 'SERAPHIM_AI',
                    content: goodResponse,
                    timestamp: Date.now(),
                    isNew: true
                };

                const evilMessage = {
                    type: 'evil',
                    speaker: 'ABYSSAL_AI',
                    content: evilResponse,
                    timestamp: Date.now() + 1000,
                    isNew: true
                };

                addMessageToFirebase(goodMessage);
                setTimeout(() => addMessageToFirebase(evilMessage), 1000);

                // Chance for AI debate
                if (Math.random() < 0.4) {
                    setTimeout(() => triggerAIDebate(goodResponse, evilResponse), 3000);
                }

            } catch (error) {
                console.error('Error getting AI responses:', error);
                messagesContainer.removeChild(messagesContainer.lastElementChild);
            } finally {
                isLoading = false;
                sendButton.disabled = false;
            }
        }

        // Trigger AI debate
        async function triggerAIDebate(goodPrevious, evilPrevious) {
            try {
                const debatePrompt = `The good AI said: "${goodPrevious}". Challenge this perspective directly.`;
                const evilRebuttal = await callOpenRouterAPI(debatePrompt, 'evil');
                
                const evilDebateMessage = {
                    type: 'evil',
                    speaker: 'ABYSSAL_AI',
                    content: evilRebuttal,
                    timestamp: Date.now(),
                    isDebate: true,
                    isNew: true
                };

                addMessageToFirebase(evilDebateMessage);

                setTimeout(async () => {
                    const goodCounterPrompt = `The evil AI challenged: "${evilRebuttal}". Respond with wisdom.`;
                    const goodCounter = await callOpenRouterAPI(goodCounterPrompt, 'good');
                    
                    const goodDebateMessage = {
                        type: 'good',
                        speaker: 'SERAPHIM_AI',
                        content: goodCounter,
                        timestamp: Date.now(),
                        isDebate: true,
                        isNew: true
                    };

                    addMessageToFirebase(goodDebateMessage);
                }, 2000);
            } catch (error) {
                console.error('Error in AI debate:', error);
            }
        }

        // Event listeners
        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Initialize 3D Models (same as before but with retro styling)
        function init3DModels() {
            // Good AI Model
            const goodContainer = document.getElementById('good-model-container');
            const goodScene = new THREE.Scene();
            const goodCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const goodRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            goodRenderer.setSize(320, 320);
            goodRenderer.setClearColor(0x000000, 0);
            goodRenderer.domElement.className = 'model-canvas';
            goodContainer.appendChild(goodRenderer.domElement);
            
            const goodAmbientLight = new THREE.AmbientLight(0x00ffff, 0.8);
            const goodDirectionalLight = new THREE.DirectionalLight(0x00ffff, 1.0);
            goodDirectionalLight.position.set(10, 10, 5);
            goodScene.add(goodAmbientLight, goodDirectionalLight);
            
            // Evil AI Model
            const evilContainer = document.getElementById('evil-model-container');
            const evilScene = new THREE.Scene();
            const evilCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const evilRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            evilRenderer.setSize(320, 320);
            evilRenderer.setClearColor(0x000000, 0);
            evilRenderer.domElement.className = 'model-canvas evil-canvas';
            evilContainer.appendChild(evilRenderer.domElement);
            
            const evilAmbientLight = new THREE.AmbientLight(0xff0040, 0.8);
            const evilDirectionalLight = new THREE.DirectionalLight(0xff0040, 1.0);
            evilDirectionalLight.position.set(-10, 10, 5);
            evilScene.add(evilAmbientLight, evilDirectionalLight);
            
            const loader = new THREE.GLTFLoader();
            
            // Load models (static)
            loader.load(GOOD_MODEL_URL, (gltf) => {
                const goodModel = gltf.scene;
                goodModel.scale.set(3, 3, 3);
                goodScene.add(goodModel);
                
                const box = new THREE.Box3().setFromObject(goodModel);
                const center = box.getCenter(new THREE.Vector3());
                goodModel.position.sub(center);
                goodCamera.position.z = 4;
                
                function renderGood() {
                    requestAnimationFrame(renderGood);
                    goodRenderer.render(goodScene, goodCamera);
                }
                renderGood();
            }, undefined, (error) => {
                goodContainer.innerHTML = '<div class="flex items-center justify-center h-full text-cyan-400 text-sm">GOOD_AI.EXE</div>';
            });
            
            loader.load(EVIL_MODEL_URL, (gltf) => {
                const evilModel = gltf.scene;
                evilModel.scale.set(3, 3, 3);
                evilScene.add(evilModel);
                
                const box = new THREE.Box3().setFromObject(evilModel);
                const center = box.getCenter(new THREE.Vector3());
                evilModel.position.sub(center);
                evilCamera.position.z = 4;
                
                function renderEvil() {
                    requestAnimationFrame(renderEvil);
                    evilRenderer.render(evilScene, evilCamera);
                }
                renderEvil();
            }, undefined, (error) => {
                evilContainer.innerHTML = '<div class="flex items-center justify-center h-full text-red-400 text-sm">EVIL_AI.EXE</div>';
            });
        }

        // Initialize everything
        window.addEventListener('load', () => {
            init3DModels();
            initFirebase();
        });
    </script>
</body>
</html>
